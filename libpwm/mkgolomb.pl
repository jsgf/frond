#!/usr/bin/perl

@ogr = ( 0, 1, 4, 9, 15, 22, 32, 34 );
#@ogr = ( 0, 3, 9, 17, 19, 32, 39, 43, 44 );
#@ogr = ( 0, 1, 6, 10, 23, 26, 34, 41, 53, 55 );
#@ogr = ( 0, 1, 4, 13, 28, 33, 47, 54, 64, 70, 72);
#@ogr = ( 0, 1, 9, 19, 24, 31, 52, 56, 58, 69, 72);
#@ogr = (0, 2, 6, 24, 29, 40, 43, 55, 68, 75, 76, 85);
#@ogr = (0, 7, 8, 17, 21, 36, 47, 63, 69, 81, 101, 104, 106);

$len = $ogr[$#ogr];


$step=$ARGV[0];
$step=16 unless $step;

print <<END;
/*
   PWM tables for Golomb ruler @ogr
   $step LED brightness levels

   DO NOT EDIT
   Generated by mkgolomb.pl
 */

#define MAX_LVL ($step-1)

END

#print "const unsigned char gamma[] = {\n";

$gamma = .45;
#$gamma = 1;

for($s=0; $s < 1; $s += 1/($step-1)) {
    my $o = ($s ** (1/$gamma)) * $len;
    my $v = int((($s**(1/$gamma)) * $len)+.5);
    #print "\t$v, /* $o $s */\n";
    push @used, $v;
    push @actual, $o;
    $used{$v} = 1;
}

print <<END;
#define PWM_MARKS	($#ogr)

#ifdef USE_FLASH
#include <avr/pgmspace.h>
#define FLASH PROGMEM
#else
#define FLASH /* */
#endif

#ifdef PWM_C
#ifndef PWM_SCALE
#define PWM_SCALE	1
#endif

#define PWM_LENGTH	($ogr[$#ogr] * PWM_SCALE)

static const unsigned char pwm_delta[PWM_MARKS] FLASH = \n{
END

my $maxd = 0;
for($i = 0; $i < $#ogr; $i++) {
    my $d = $ogr[$i+1]-$ogr[$i];
    $maxd = $d if $d > $maxd;
    print "\t-($d * PWM_SCALE),\n";
}


print <<END;
};

#if ($maxd * PWM_SCALE) > 255
#warning $maxd * PWM_SCALE > 255
#endif
struct golomb_map {
	unsigned char start, stop;
};

static const struct golomb_map golomb_map[] FLASH = {
END

$needed=0;
$level=0;
len:
foreach $l (@used) {
    my $wanted = shift @actual;
    my $missing = $l;
 missing:
    if ($missing == 0) {
	print "\t/* Skipping $wanted */\n";
	next;
    }
	
    for($i = 0; $i <= $#ogr; $i++) {
	for($j = $i+1; $j <= $#ogr; $j++) {
	    #print "** $i $ogr[$i] $j $ogr[j]\n";
	    next len unless $needed || defined $used{$l};
	    if (abs($ogr[$i] - $ogr[$j]) == $l) {
		my $error = sprintf("%+.3f", $l - $wanted);
		my $percerr = sprintf("%+6.2f%%", ($l - $wanted) * 100. / $wanted);
		my $wanted = sprintf("%.5g", $wanted);
		my $approx = $needed ? "(approx $missing) " : "";
		$missing=0;
		my $start = $i;
		my $end = $j;
		$end = 0 if $end == $#ogr;
		
		printf "\t{ %d, %d },\t/* [%2d] %2d: (%2d, %2d) want=%8s err=%7s %s %s*/\n",
		  $start, $end, $level++, $l, $ogr[$i], $ogr[$j], $wanted, $error, $percerr, $approx;
		$needed = 0;
	    }
	}
    }
    if ($missing) {
	my $s, $e = -1, $i;
	
	for($si = 0; $si <= $#ogr; $si++) {
	    for($sj = $si+1; $sj <= $#ogr; $sj++) {
		my $len = abs($ogr[$si] - $ogr[$sj]);
		my $err = abs($len - $wanted);
		#print "$len $err\n";
		if ($e == -1 || $e > $err) {
		    $e = $err;
		    $i = $len;
		}
	    }
	}
	$needed = 1;
	$l = $i;
	goto missing;
    }
}

print <<END;
};

#define MIN_LVL		($step-$level)
#endif /* PWM_C */
END
